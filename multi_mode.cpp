#include "multi_mode.h"
#include "multiplay.h"

void MultiPlayModeServerSide::UpdateResult(std::map<int, CLIENT_DATA_SERVER_SIDE> &clients) {
	// 中間リザルトの経過時間を計算
	float time = time_ - maxTime_ - resultTime_;
	
	// 時間がマイナスなら終了（まだ中間リザルトではない）
	if (time < 0.0f) return;


}

void MultiPlayModeClientSide::DrawStart(RESPONSE_PLAYER &players, Vector2 offset) {
	float time = players.time;

	const float SPAWN_ANIMATION_TIME = 3.0f;
	float spawnSpanTime = SPAWN_ANIMATION_TIME / players.clients.size();	// スポーンさせる間隔
	// スポーンさせる
	if (spawnSpanTime * clientSpawnCount <= time) {

		// イテレータ
		auto iterator = players.clients.begin();

		// アニメーションするプレイヤーのイテレータ
		for (int i = 0; i < clientSpawnCount && iterator != players.clients.end(); i++) iterator++;

		// イテレータが存在するなら
		if (iterator != players.clients.end()) {
			// アニメーションする
			MultiPlayClient::clients[iterator->id]->ShowEntry();
		}
		clientSpawnCount++;
	}
}

void MultiPlayModeClientSide::DrawResult(RESPONSE_PLAYER &players, Vector2 offset) {
	// 中間リザルトの経過時間を計算
	float time = players.time - players.maxTime + resultTime_;

	// 時間がマイナスなら終了（まだ中間リザルトではない）
	if (time < 0.0f) return;

	auto afterClients = players.clients;
	const float RANKING_SORT_ANIMATION_TIME = 1.0f;

	// ランキングのアニメーション
	if (time <= RANKING_SORT_ANIMATION_TIME) {
		// 0.5秒ごとにスキルオーブをドロップ
		if (500 < dropSkillOrbCoolTimer.GetNowTime()) {

		}
		
		//// ランキングをソートする
		//sort(beforeClients);									// ゲーム開始時のランキング表
		//sort(afterClients);										// 現在のランキング表

		//int playerNum = players.clients.size();					// プレイヤー数
		//float t = time / RANKING_SORT_ANIMATION_TIME;			// 時間の割合
		//t *= t;													// 二次関数に変換させる


		//for (auto &client : players.clients) {
		//	int id = client.id;									// ID
		//	int preRank = get_rank(beforeClients, id);			// 1ゲーム前のランク
		//	int rank = get_rank(afterClients, id);				// 現在のランク

		//	float height = 100.0f;								// キャラクター絵の高さ
		//	float y = rank - playerNum * 0.5f;					// 現在のランキングのY座標
		//	float preY = preRank - playerNum * 0.5f;			// 1ゲーム前のランキングのY座標
		//	Vector2 startPosition = Vector2::Up * y * height;	// 始点の座標
		//	Vector2 endPosition = Vector2::Up * preY * height;	// 終点の座標
		//	Vector2 position = MATH::Leap(startPosition, endPosition, t);	// 線形補完
		//	DrawSpriteCenter(0, position, 0.0f, Vector2(600, height), Color::White);
		//}
	}
}
